package org.usfirst.frc.team6500.robot;

import org.usfirst.frc.team6500.robot.autonomous.DriveBaseline;
import org.usfirst.frc.team6500.robot.subsystems.*;

import edu.wpi.first.wpilibj.ADXRS450_Gyro;
import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Relay;
import edu.wpi.first.wpilibj.Servo;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class Robot extends IterativeRobot {
	Command autonomousCommand;
	
	public static OI oi;
	
	//Subsystems
	public static DriveTrain drive;
	public static Control control;
	public static Elevator elevator;
	public static Flaps gearFlaps;
	public static Camera pantilt;
	public static Dumper dumper;
	public static Gyro gyroscope;
	
	//A variable that makes sure the robot doesn't try and run the autonomous portion of code more than once
	boolean autonomous = true;
	
	static String driveMode = "Disabled";
	
	//If a control delay variable is not created, the joystick's input is read too fast
	//and the driver cycles through options way too fast to control it.
	static int controldelay = 0;
	
	//A variable for timing things that we don't want to happen super often
	int tick = 0;
	
//	double tiltpos = 0.635;
	
	public void switchMode(){
		if (driveMode == "Disable") {
			driveMode = "Normal";
		}else{
			if (driveMode == "Normal") {
				driveMode = "Disable";
			}
		}
	}
	
	//The @Override tag means we are overriding the method that was defined in the superclass (IterativeRobot in this case)
	//The robotInit method happens once when the RoboRio starts up and never again.
	//We need to define everything that we will use later now
	@Override
	public void robotInit() {
		drive = new DriveTrain();
		control = new Control();
		elevator = new Elevator();
		gearFlaps = new Flaps();
		pantilt = new Camera();
		dumper = new Dumper();
		gyroscope = new Gyro();
		oi = new OI();
		
		driveMode = "Disable";
		CameraServer.getInstance().startAutomaticCapture();
	}
	
	@Override
	public void autonomousInit(){
		autonomousCommand = new DriveBaseline();
		autonomousCommand.start();
	}
	
	//This code runs when the autonomous portion of the match is happening,
	//and it (should) only runs once (see the autonomous variable)
	@Override
	public void autonomousPeriodic() {
		Scheduler.getInstance().run();
	}
	
	@Override
	public void teleopInit(){
		autonomousCommand.cancel();
	}
	
	//This method loops as fast as possible while the robot is in
	@SuppressWarnings("deprecation")
	//the teleoperated (controlled by driver) period of the match
	@Override
	public void teleopPeriodic() {
		Scheduler.getInstance().run();
		
		//If the the robot is in normal drive,
		if (driveMode == "Normal") {
			if (rightcontroller.getRawButton(12) && rightcontroller.getRawButton(1)) {
				nitro = true;
			}else{
				nitro = false;
			}
			//tell the RobotDrive object to do tank drive.
			//It gets the power for the left and right side and multiplies it by the multiplier form the throttle
			//drive.tankDrive(getLeftPower() * multiplier, getRightPower() * multiplier);
			//drive.arcadeDrive(rightcontroller);
			if (!nitro) {
				
				double leftboost = 0.0;
				if (leftcontroller.getTrigger()) {
					leftboost = 0.05;
				}
				double rightboost = 0.0;
				if (rightcontroller.getTrigger()) {
					rightboost = 0.05;
				}
				
				if (controldelay == 0 && rightcontroller.getRawButton(11)) {
					if (driveType == "Tank") {
						driveType = "Arcade";
					}else{
						driveType = "Tank";
					}
					System.out.println(driveType);
					controldelay = 15;
				}
				
				if (driveType == "Tank") {
					drive.tankDrive(leftcontroller.getY() * -1, rightcontroller.getY() * -1, multiplier + rightboost);
				}else{
					drive.arcadeDrive(rightcontroller.getY() * -1, rightcontroller.getX() * -1, multiplier + rightboost);
				}
				
				
				
				//Actuator code
				//if (rightcontroller.getXButton()) {
				if (rightcontroller.getRawButton(3) && controldelay == 0) {
					if (relaystate == "Reverse") {
						relaystate = "Forward";
						relayone.set(Relay.Value.kForward);
					}else{
						relaystate = "Reverse";
						relayone.set(Relay.Value.kReverse);
					}
					controldelay = 15;
				}
				
				//Pan\Tilt code
				int POVPos = rightcontroller.getPOV();
				if (POVPos == 180) {
					if (tiltpos > 0.29){
					tiltpos = tiltpos - 0.02;
					}
					tilt.set(tiltpos);
				}else{
					if (POVPos == 0) {
						if (tiltpos < 0.98){
							tiltpos = tiltpos + 0.02;
						}
						tilt.set(tiltpos);
					}
				}
				
				if (POVPos == 90) {
					if (panpos < .98){
					panpos = panpos + .02;
					}
					pan.set(panpos);
				}else{
					if (POVPos == 270) {
						if (panpos > .02){
						panpos = panpos - .02;
						}
						pan.set(panpos);
					}
				}
				
				//Elevator code
				if (rightcontroller.getRawButton(4)) {
					elevator.set(-1);
				}else{
					if (rightcontroller.getRawButton(6)) {
						elevator.set(1);
					}else{
						elevator.set(0.0);
					}
				}
				
				if (rightcontroller.getRawButton(5) && controldelay == 0) {
					if (flaps) {
						flaps = false;
					}else{
						flaps = true;
					}
					updateFlaps();
					controldelay = 15;
				}
			} else {
				drive.tankDrive(1, 1, 1);
			}
		}
		
		//If the robot is in debugging mode,
		if (driveMode == "Debugging") {
			
		}
		//If the driveMode 
		if (driveMode == "Disable") {
			drive.brakeStop();
		}
//		drive.arcadeDrive(rightcontroller.getY() * multiplier, -rightcontroller.getX() * multiplier);
		if (controldelay > 0) { controldelay = controldelay - 1; }
		if (tick < 100) { tick = tick + 1; }
		if (tick == 100) { tick = 0; }
		if (tick == 10) {
			//System.out.println("Angle: " + gyro.getAngle() + ", Rate:" + gyro.getRate());
			//System.out.println(readUltrasonic());
//			if (testServo.get() > 0.9) {
//				testServo.set(-1);
//			}else{
//				testServo.set(1);
//			}
//			rightcontroller.setRumble(GenericHID.RumbleType.kRightRumble, 1.0);
		}
		
		//Putting values to the SmartDashboard
		SmartDashboard.putNumber("Gyroscope Angle", gyroscope.gyroAngle());
		SmartDashboard.putNumber("Pan Position", pantilt.panpos);
		SmartDashboard.putNumber("Tilt Position", pantilt.tiltpos);
		SmartDashboard.putString("Drive Mode", driveMode);
		SmartDashboard.putBoolean("Zoom Zoom!", nitro);
	}

	@Override
	public void testPeriodic() {

	}
}
